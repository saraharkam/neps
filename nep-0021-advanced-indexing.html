<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>NEP 21 — Simplified and explicit advanced indexing &mdash; NumPy Enhancement Proposals</title>
    
    <link rel="stylesheet" type="text/css" href="_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="_static/css/spc-extend.css">
    <link rel="stylesheet" href="_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" >
    <link rel="search" title="Search" href="search.html" >
    <link rel="top" title="NumPy Enhancement Proposals" href="index.html" >
    <link rel="next" title="NEP 1 — A Simple File Format for NumPy Arrays" href="nep-0001-npy-format.html" >
    <link rel="prev" title="NEP 19 — Random Number Generator Policy" href="nep-0019-rng-policy.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="index.html">
      <img style="border: 0;" alt="SciPy" src="_static/img/scipy_org_logo.gif"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://scipy.org/">Scipy.org</a></li>
        <li class="active"><a href="https://docs.scipy.org/">Docs</a></li>
        
        <li class="active"><a href="index.html">NumPy Enhancement Proposals</a></li>
        
 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="nep-0001-npy-format.html" title="NEP 1 — A Simple File Format for NumPy Arrays"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="nep-0019-rng-policy.html" title="NEP 19 — Random Number Generator Policy"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="nep-21-simplified-and-explicit-advanced-indexing">
<h1>NEP 21 — Simplified and explicit advanced indexing<a class="headerlink" href="#nep-21-simplified-and-explicit-advanced-indexing" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Sebastian Berg</td>
</tr>
<tr class="field-even field"><th class="field-name">Author:</th><td class="field-body">Stephan Hoyer &lt;<a class="reference external" href="mailto:shoyer&#37;&#52;&#48;google&#46;com">shoyer<span>&#64;</span>google<span>&#46;</span>com</a>&gt;</td>
</tr>
<tr class="field-odd field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field-even field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field-odd field"><th class="field-name">Created:</th><td class="field-body">2015-08-27</td>
</tr>
</tbody>
</table>
<div class="section" id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>NumPy’s “advanced” indexing support for indexing array with other arrays is
one of its most powerful and popular features. Unfortunately, the existing
rules for advanced indexing with multiple array indices are typically confusing
to both new, and in many cases even old, users of NumPy. Here we propose an
overhaul and simplification of advanced indexing, including two new “indexer”
attributes <code class="docutils literal notranslate"><span class="pre">oindex</span></code> and <code class="docutils literal notranslate"><span class="pre">vindex</span></code> to facilitate explicit indexing.</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<div class="section" id="existing-indexing-operations">
<h3>Existing indexing operations<a class="headerlink" href="#existing-indexing-operations" title="Permalink to this headline">¶</a></h3>
<p>NumPy arrays currently support a flexible range of indexing operations:</p>
<ul class="simple">
<li>“Basic” indexing involving only slices, integers, <code class="docutils literal notranslate"><span class="pre">np.newaxis</span></code> and ellipsis
(<code class="docutils literal notranslate"><span class="pre">...</span></code>), e.g., <code class="docutils literal notranslate"><span class="pre">x[0,</span> <span class="pre">:3,</span> <span class="pre">np.newaxis]</span></code> for selecting the first element
from the 0th axis, the first three elements from the 1st axis and inserting a
new axis of size 1 at the end. Basic indexing always return a view of the
indexed array’s data.</li>
<li>“Advanced” indexing, also called “fancy” indexing, includes all cases where
arrays are indexed by other arrays. Advanced indexing always makes a copy:<ul>
<li>“Boolean” indexing by boolean arrays, e.g., <code class="docutils literal notranslate"><span class="pre">x[x</span> <span class="pre">&gt;</span> <span class="pre">0]</span></code> for
selecting positive elements.</li>
<li>“Vectorized” indexing by one or more integer arrays, e.g., <code class="docutils literal notranslate"><span class="pre">x[[0,</span> <span class="pre">1]]</span></code>
for selecting the first two elements along the first axis. With multiple
arrays, vectorized indexing uses broadcasting rules to combine indices along
multiple dimensions. This allows for producing a result of arbitrary shape
with arbitrary elements from the original arrays.</li>
<li>“Mixed” indexing involving any combinations of the other advancing types.
This is no more powerful than vectorized indexing, but is sometimes more
convenient.</li>
</ul>
</li>
</ul>
<p>For clarity, we will refer to these existing rules as “legacy indexing”.
This is only a high-level summary; for more details, see NumPy’s documentation
and and <cite>Examples</cite> below.</p>
</div>
<div class="section" id="outer-indexing">
<h3>Outer indexing<a class="headerlink" href="#outer-indexing" title="Permalink to this headline">¶</a></h3>
<p>One broadly useful class of indexing operations is not supported:</p>
<ul class="simple">
<li>“Outer” or orthogonal indexing treats one-dimensional arrays equivalently to
slices for determining output shapes. The rule for outer indexing is that the
result should be equivalent to independently indexing along each dimension
with integer or boolean arrays as if both the indexed and indexing arrays
were one-dimensional. This form of indexing is familiar to many users of other
programming languages such as MATLAB, Fortran and R.</li>
</ul>
<p>The reason why NumPy omits support for outer indexing is that the rules for
outer and vectorized conflict. Consider indexing a 2D array by two 1D integer
arrays, e.g., <code class="docutils literal notranslate"><span class="pre">x[[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1]]</span></code>:</p>
<ul class="simple">
<li>Outer indexing is equivalent to combining multiple integer indices with
<code class="docutils literal notranslate"><span class="pre">itertools.product()</span></code>. The result in this case is another 2D array with
all combinations of indexed elements, e.g.,
<code class="docutils literal notranslate"><span class="pre">np.array([[x[0,</span> <span class="pre">0],</span> <span class="pre">x[0,</span> <span class="pre">1]],</span> <span class="pre">[x[1,</span> <span class="pre">0],</span> <span class="pre">x[1,</span> <span class="pre">1]]])</span></code></li>
<li>Vectorized indexing is equivalent to combining multiple integer indices with
<code class="docutils literal notranslate"><span class="pre">zip()</span></code>. The result in this case is a 1D array containing the diagonal
elements, e.g., <code class="docutils literal notranslate"><span class="pre">np.array([x[0,</span> <span class="pre">0],</span> <span class="pre">x[1,</span> <span class="pre">1]])</span></code>.</li>
</ul>
<p>This difference is a frequent stumbling block for new NumPy users. The outer
indexing model is easier to understand, and is a natural generalization of
slicing rules. But NumPy instead chose to support vectorized indexing, because
it is strictly more powerful.</p>
<p>It is always possible to emulate outer indexing by vectorized indexing with
the right indices. To make this easier, NumPy includes utility objects and
functions such as <code class="docutils literal notranslate"><span class="pre">np.ogrid</span></code> and <code class="docutils literal notranslate"><span class="pre">np.ix_</span></code>, e.g.,
<code class="docutils literal notranslate"><span class="pre">x[np.ix_([0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">1])]</span></code>. However, there are no utilities for emulating
fully general/mixed outer indexing, which could unambiguously allow for slices,
integers, and 1D boolean and integer arrays.</p>
</div>
<div class="section" id="mixed-indexing">
<h3>Mixed indexing<a class="headerlink" href="#mixed-indexing" title="Permalink to this headline">¶</a></h3>
<p>NumPy’s existing rules for combining multiple types of indexing in the same
operation are quite complex, involving a number of edge cases.</p>
<p>One reason why mixed indexing is particularly confusing is that at first glance
the result works deceptively like outer indexing. Returning to our example of a
2D array, both <code class="docutils literal notranslate"><span class="pre">x[:2,</span> <span class="pre">[0,</span> <span class="pre">1]]</span></code> and <code class="docutils literal notranslate"><span class="pre">x[[0,</span> <span class="pre">1],</span> <span class="pre">:2]</span></code> return 2D arrays with
axes in the same order as the original array.</p>
<p>However, as soon as two or more non-slice objects (including integers) are
introduced, vectorized indexing rules apply. The axes introduced by the array
indices are at the front, unless all array indices are consecutive, in which
case NumPy deduces where the user “expects” them to be. Consider indexing a 3D
array <code class="docutils literal notranslate"><span class="pre">arr</span></code> with shape <code class="docutils literal notranslate"><span class="pre">(X,</span> <span class="pre">Y,</span> <span class="pre">Z)</span></code>:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">arr[:,</span> <span class="pre">[0,</span> <span class="pre">1],</span> <span class="pre">0]</span></code> has shape <code class="docutils literal notranslate"><span class="pre">(X,</span> <span class="pre">2)</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">arr[[0,</span> <span class="pre">1],</span> <span class="pre">0,</span> <span class="pre">:]</span></code> has shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">Z)</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">arr[0,</span> <span class="pre">:,</span> <span class="pre">[0,</span> <span class="pre">1]]</span></code> has shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">Y)</span></code>, not <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">2)</span></code>!</li>
</ol>
<p>These first two cases are intuitive and consistent with outer indexing, but
this last case is quite surprising, even to many higly experienced NumPy users.</p>
<p>Mixed cases involving multiple array indices are also surprising, and only
less problematic because the current behavior is so useless that it is rarely
encountered in practice. When a boolean array index is mixed with another boolean or
integer array, boolean array is converted to integer array indices (equivalent
to <code class="docutils literal notranslate"><span class="pre">np.nonzero()</span></code>) and then broadcast. For example, indexing a 2D array of
size <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">2)</span></code> like <code class="docutils literal notranslate"><span class="pre">x[[True,</span> <span class="pre">False],</span> <span class="pre">[True,</span> <span class="pre">False]]</span></code> produces a 1D vector
with shape <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>, not a 2D sub-matrix with shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">1)</span></code>.</p>
<p>Mixed indexing seems so tricky that it is tempting to say that it never should
be used. However, it is not easy to avoid, because NumPy implicitly adds full
slices if there are fewer indices than the full dimensionality of the indexed
array. This means that indexing a 2D array like <cite>x[[0, 1]]`</cite> is equivalent to
<code class="docutils literal notranslate"><span class="pre">x[[0,</span> <span class="pre">1],</span> <span class="pre">:]</span></code>. These cases are not surprising, but they constrain the
behavior of mixed indexing.</p>
</div>
<div class="section" id="indexing-in-other-python-array-libraries">
<h3>Indexing in other Python array libraries<a class="headerlink" href="#indexing-in-other-python-array-libraries" title="Permalink to this headline">¶</a></h3>
<p>Indexing is a useful and widely recognized mechanism for accessing
multi-dimensional array data, so it is no surprise that many other libraries in
the scientific Python ecosystem also support array indexing.</p>
<p>Unfortunately, the full complexity of NumPy’s indexing rules mean that it is
both challenging and undesirable for other libraries to copy its behavior in all
of its nuance. The only full implementation of NumPy-style indexing is NumPy
itself. This includes projects like dask.array and h5py, which support <em>most</em>
types of array indexing in some form, and otherwise attempt to copy NumPy’s API
exactly.</p>
<p>Vectorized indexing in particular can be challenging to implement with array
storage backends not based on NumPy. In contrast, indexing by 1D arrays along
at least one dimension in the style of outer indexing is much more acheivable.
This has led many libraries (including dask and h5py) to attempt to define a
safe subset of NumPy-style indexing that is equivalent to outer indexing, e.g.,
by only allowing indexing with an array along at most one dimension. However,
this is quite challenging to do correctly in a general enough way to be useful.
For example, the current versions of dask and h5py both handle mixed indexing
in case 3 above inconsistently with NumPy. This is quite likely to lead to
bugs.</p>
<p>These inconsistencies, in addition to the broader challenge of implementing
every type of indexing logic, make it challenging to write high-level array
libraries like xarray or dask.array that can interchangeably index many types of
array storage. In contrast, explicit APIs for outer and vectorized indexing in
NumPy would provide a model that external libraries could reliably emulate, even
if they don’t support every type of indexing.</p>
</div>
</div>
<div class="section" id="high-level-changes">
<h2>High level changes<a class="headerlink" href="#high-level-changes" title="Permalink to this headline">¶</a></h2>
<p>Inspired by multiple “indexer” attributes for controlling different types
of indexing behavior in pandas, we propose to:</p>
<ol class="arabic simple">
<li>Introduce <code class="docutils literal notranslate"><span class="pre">arr.oindex[indices]</span></code> which allows array indices, but
uses outer indexing logic.</li>
<li>Introduce <code class="docutils literal notranslate"><span class="pre">arr.vindex[indices]</span></code> which use the current
“vectorized”/broadcasted logic but with two differences from
legacy indexing:<ul>
<li>Boolean indices are not supported. All indices must be integers,
integer arrays or slices.</li>
<li>The integer index result dimensions are always the first axes
of the result array. No transpose is done, even for a single
integer array index.</li>
</ul>
</li>
<li>Plain indexing on arrays will start to give warnings and eventually
errors in cases where one of the explicit indexers should be preferred:<ul>
<li>First, in all cases where legacy and outer indexing would give
different results.</li>
<li>Later, potentially in all cases involving an integer array.</li>
</ul>
</li>
</ol>
<p>These constraints are sufficient for making indexing generally consistent
with expectations and providing a less surprising learning curve with
<code class="docutils literal notranslate"><span class="pre">oindex</span></code>.</p>
<p>Note that all things mentioned here apply both for assignment as well as
subscription.</p>
<p>Understanding these details is <em>not</em> easy. The <cite>Examples</cite> section in the
discussion gives code examples.
And the hopefully easier <cite>Motivational Example</cite> provides some
motivational use-cases for the general ideas and is likely a good start for
anyone not intimately familiar with advanced indexing.</p>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proposed-rules">
<h3>Proposed rules<a class="headerlink" href="#proposed-rules" title="Permalink to this headline">¶</a></h3>
<p>From the three problems noted above some expectations for NumPy can
be deduced:</p>
<ol class="arabic simple">
<li>There should be a prominent outer/orthogonal indexing method such as
<code class="docutils literal notranslate"><span class="pre">arr.oindex[indices]</span></code>.</li>
<li>Considering how confusing vectorized/fancy indexing can be, it should
be possible to be made more explicitly (e.g. <code class="docutils literal notranslate"><span class="pre">arr.vindex[indices]</span></code>).</li>
<li>A new <code class="docutils literal notranslate"><span class="pre">arr.vindex[indices]</span></code> method, would not be tied to the
confusing transpose rules of fancy indexing, which is for example
needed for the simple case of a single advanced index. Thus,
no transposing should be done. The axes created by the integer array
indices are always inserted at the front, even for a single index.</li>
<li>Boolean indexing is conceptionally outer indexing. Broadcasting
together with other advanced indices in the manner of legacy
indexing is generally not helpful or well defined.
A user who wishes the “<code class="docutils literal notranslate"><span class="pre">nonzero</span></code>” plus broadcast behaviour can thus
be expected to do this manually. Thus, <code class="docutils literal notranslate"><span class="pre">vindex</span></code> does not need to
support boolean index arrays.</li>
<li>An <code class="docutils literal notranslate"><span class="pre">arr.legacy_index</span></code> attribute should be implemented to support
legacy indexing. This gives a simple way to update existing codebases
using legacy indexing, which will make the deprecation of plain indexing
behavior easier. The longer name <code class="docutils literal notranslate"><span class="pre">legacy_index</span></code> is intentionally chosen
to be explicit and discourage its use in new code.</li>
<li>Plain indexing <code class="docutils literal notranslate"><span class="pre">arr[...]</span></code> should return an error for ambiguous cases.
For the beginning, this probably means cases where <code class="docutils literal notranslate"><span class="pre">arr[ind]</span></code> and
<code class="docutils literal notranslate"><span class="pre">arr.oindex[ind]</span></code> return different results give deprecation warnings.
This includes every use of vectorized indexing with multiple integer arrays.
Due to the transposing behaviour, this means that``arr[0, :, index_arr]``
will be deprecated, but <code class="docutils literal notranslate"><span class="pre">arr[:,</span> <span class="pre">0,</span> <span class="pre">index_arr]</span></code> will not for the time being.</li>
<li>To ensure that existing subclasses of <cite>ndarray</cite> that override indexing
do not inadvertently revert to default behavior for indexing attributes,
these attribute should have explicit checks that disable them if
<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> or <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> has been overriden.</li>
</ol>
<p>Unlike plain indexing, the new indexing attributes are explicitly aimed
at higher dimensional indexing, several additional changes should be implemented:</p>
<ul class="simple">
<li>The indexing attributes will enforce exact dimension and indexing match.
This means that no implicit ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>) will be added. Unless
an ellipsis is present the indexing expression will thus only work for
an array with a specific number of dimensions.
This makes the expression more explicit and safeguards against wrong
dimensionality of arrays.
There should be no implications for “duck typing” compatibility with
builtin Python sequences, because Python sequences only support a limited
form of “basic indexing” with integers and slices.</li>
<li>The current plain indexing allows for the use of non-tuples for
multi-dimensional indexing such as <code class="docutils literal notranslate"><span class="pre">arr[[slice(None),</span> <span class="pre">2]]</span></code>.
This creates some inconsistencies and thus the indexing attributes
should only allow plain python tuples for this purpose.
(Whether or not this should be the case for plain indexing is a
different issue.)</li>
<li>The new attributes should not use getitem to implement setitem,
since it is a cludge and not useful for vectorized
indexing. (not implemented yet)</li>
</ul>
</div>
<div class="section" id="open-questions">
<h3>Open Questions<a class="headerlink" href="#open-questions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>The names <code class="docutils literal notranslate"><span class="pre">oindex</span></code>, <code class="docutils literal notranslate"><span class="pre">vindex</span></code> and <code class="docutils literal notranslate"><span class="pre">legacy_index</span></code> are just suggestions at
the time of writing this, another name NumPy has used for something like
<code class="docutils literal notranslate"><span class="pre">oindex</span></code> is <code class="docutils literal notranslate"><span class="pre">np.ix_</span></code>. See also below.</li>
<li><code class="docutils literal notranslate"><span class="pre">oindex</span></code> and <code class="docutils literal notranslate"><span class="pre">vindex</span></code> could always return copies, even when no array
operation occurs. One argument for allowing a view return is that this way
<code class="docutils literal notranslate"><span class="pre">oindex</span></code> can be used as a general index replacement.
However, there is one argument for returning copies. It is possible for
<code class="docutils literal notranslate"><span class="pre">arr.vindex[array_scalar,</span> <span class="pre">...]</span></code>, where <code class="docutils literal notranslate"><span class="pre">array_scalar</span></code> should be
a 0-D array but is not, since 0-D arrays tend to be converted.
Copying always “fixes” this possible inconsistency.</li>
<li>The final state to morph plain indexing in is not fixed in this PEP.
It is for example possible that <cite>arr[index]`</cite> will be equivalent to
<code class="docutils literal notranslate"><span class="pre">arr.oindex</span></code> at some point in the future.
Since such a change will take years, it seems unnecessary to make
specific decisions at this time.</li>
<li>The proposed changes to plain indexing could be postponed indefinitely or
not taken in order to not break or force major fixes to existing code bases.</li>
</ul>
</div>
<div class="section" id="alternative-names">
<h3>Alternative Names<a class="headerlink" href="#alternative-names" title="Permalink to this headline">¶</a></h3>
<p>Possible names suggested (more suggestions will be added).</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="35%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Orthogonal</strong></td>
<td>oindex</td>
<td>oix</td>
</tr>
<tr class="row-even"><td><strong>Vectorized</strong></td>
<td>vindex</td>
<td>vix</td>
</tr>
<tr class="row-odd"><td><strong>Legacy</strong></td>
<td>legacy_index</td>
<td>l/findex</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="subclasses">
<h3>Subclasses<a class="headerlink" href="#subclasses" title="Permalink to this headline">¶</a></h3>
<p>Subclasses are a bit problematic in the light of these changes. There are
some possible solutions for this. For most subclasses (those which do not
provide <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> or <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code>) the special attributes should
just work. Subclasses that <em>do</em> provide it must be updated accordingly
and should preferably not subclass <code class="docutils literal notranslate"><span class="pre">oindex</span></code> and <code class="docutils literal notranslate"><span class="pre">vindex</span></code>.</p>
<p>All subclasses will inherit the attributes, however, the implementation
of <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> on these attributes should test
<code class="docutils literal notranslate"><span class="pre">subclass.__getitem__</span> <span class="pre">is</span> <span class="pre">ndarray.__getitem__</span></code>. If not, the
subclass has special handling for indexing and <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>
should be raised, requiring that the indexing attributes is also explicitly
overwritten. Likewise, implementations of <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> should check to see
if <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> is overriden.</p>
<p>A further question is how to facilitate implementing the special attributes.
Also there is the weird functionality where <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> calls
<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> for non-advanced indices. It might be good to avoid it for
the new attributes, but on the other hand, that may make it even more
confusing.</p>
<p>To facilitate implementations we could provide functions similar to
<code class="docutils literal notranslate"><span class="pre">operator.itemgetter</span></code> and <code class="docutils literal notranslate"><span class="pre">operator.setitem</span></code> for the attributes.
Possibly a mixin could be provided to help implementation. These improvements
are not essential to the initial implementation, so they are saved for
future work.</p>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Implementation would start with writing special indexing objects available
through <code class="docutils literal notranslate"><span class="pre">arr.oindex</span></code>, <code class="docutils literal notranslate"><span class="pre">arr.vindex</span></code>, and <code class="docutils literal notranslate"><span class="pre">arr.legacy_index</span></code> to allow these
indexing operations. Also, we would need to start to deprecate those plain index
operations which are not ambiguous.
Furthermore, the NumPy code base will need to use the new attributes and
tests will have to be adapted.</p>
</div>
<div class="section" id="backward-compatibility">
<h2>Backward compatibility<a class="headerlink" href="#backward-compatibility" title="Permalink to this headline">¶</a></h2>
<p>As a new feature, no backward compatibility issues with the new <code class="docutils literal notranslate"><span class="pre">vindex</span></code>
and <code class="docutils literal notranslate"><span class="pre">oindex</span></code> attributes would arise.</p>
<p>To facilitate backwards compatibility as much as possible, we expect a long
deprecation cycle for legacy indexing behavior and propose the new
<code class="docutils literal notranslate"><span class="pre">legacy_index</span></code> attribute.</p>
<p>Some forward compatibility issues with subclasses that do not specifically
implement the new methods may arise.</p>
</div>
<div class="section" id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline">¶</a></h2>
<p>NumPy may not choose to offer these different type of indexing methods, or
choose to only offer them through specific functions instead of the proposed
notation above.</p>
<p>We don’t think that new functions are a good alternative, because indexing
notation <code class="docutils literal notranslate"><span class="pre">[]</span></code> offer some syntactic advantages in Python (i.e., direct
creation of slice objects) compared to functions.</p>
<p>A more reasonable alternative would be write new wrapper objects for alternative
indexing with functions rather than methods (e.g., <code class="docutils literal notranslate"><span class="pre">np.oindex(arr)[indices]</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">arr.oindex[indices]</span></code>). Functionally, this would be equivalent,
but indexing is such a common operation that we think it is important to
minimize syntax and worth implementing it directly on <cite>ndarray</cite> objects
themselves. Indexing attributes also define a clear interface that is easier
for alternative array implementations to copy, nonwithstanding ongoing
efforts to make it easier to override NumPy functions <a class="footnote-reference" href="#id5" id="id1">[2]</a>.</p>
</div>
<div class="section" id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this headline">¶</a></h2>
<p>The original discussion about vectorized vs outer/orthogonal indexing arose
on the NumPy mailing list:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://mail.python.org/pipermail/numpy-discussion/2015-April/072550.html">https://mail.python.org/pipermail/numpy-discussion/2015-April/072550.html</a></li>
</ul>
</div></blockquote>
<p>Some discussion can be found on the original pull request for this NEP:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/numpy/numpy/pull/6256">https://github.com/numpy/numpy/pull/6256</a></li>
</ul>
</div></blockquote>
<p>Python implementations of the indexing operations can be found at:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="https://github.com/numpy/numpy/pull/5749">https://github.com/numpy/numpy/pull/5749</a></li>
<li><a class="reference external" href="https://gist.github.com/shoyer/c700193625347eb68fee4d1f0dc8c0c8">https://gist.github.com/shoyer/c700193625347eb68fee4d1f0dc8c0c8</a></li>
</ul>
</div></blockquote>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>Since the various kinds of indexing is hard to grasp in many cases, these
examples hopefully give some more insights. Note that they are all in terms
of shape.
In the examples, all original dimensions have 5 or more elements,
advanced indexing inserts smaller dimensions.
These examples may be hard to grasp without working knowledge of advanced
indexing as of NumPy 1.9.</p>
<p>Example array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="legacy-fancy-indexing">
<h2>Legacy fancy indexing<a class="headerlink" href="#legacy-fancy-indexing" title="Permalink to this headline">¶</a></h2>
<p>Note that the same result can be achieved with <code class="docutils literal notranslate"><span class="pre">arr.legacy_index</span></code>, but the
“future error” will still work in this case.</p>
<p>Single index is transposed (this is the same for all indexing types):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 6, 7, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1, 7, 8)</span>
</pre></div>
</div>
<p>Multiple indices are transposed <em>if</em> consecutive:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># future error</span>
<span class="go">(5, 1, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># future error</span>
<span class="go">(1, 5, 7)</span>
</pre></div>
</div>
<p>It is important to note that a scalar <em>is</em> integer array index in this sense
(and gets broadcasted with the other advanced index):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># future error (scalar is &quot;fancy&quot;)</span>
<span class="go">(1, 5, 7)</span>
</pre></div>
</div>
<p>Single boolean index can act on multiple dimensions (especially the whole
array). It has to match (as of 1.10. a deprecation warning) the dimensions.
The boolean index is otherwise identical to (multiple consecutive) integer
array indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create boolean index with one True value for the last two dimensions:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bindx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bindx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 6)</span>
</pre></div>
</div>
<p>The combination with anything that is not a scalar is confusing, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># bindx result broadcasts with [0]</span>
<span class="go">(1, 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># IndexError</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>Outer indexing<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Multiple indices are “orthogonal” and their result axes are inserted
at the same place (they are not broadcasted):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1, 2, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1, 7, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1, 7)</span>
</pre></div>
</div>
<p>Boolean indices results are always inserted where the index is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create boolean index with one True value for the last two dimensions:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bindx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bindx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 1)</span>
</pre></div>
</div>
<p>Nothing changed in the presence of other advanced indices since:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 6, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 2, 1)</span>
</pre></div>
</div>
</div>
<div class="section" id="vectorized-inner-indexing">
<h2>Vectorized/inner indexing<a class="headerlink" href="#vectorized-inner-indexing" title="Permalink to this headline">¶</a></h2>
<p>Multiple indices are broadcasted and iterated as one like fancy indexing,
but the new axes are always inserted at the front:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 5, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 5, 7)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 5, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 5, 7)</span>
</pre></div>
</div>
<p>Boolean indices results are always inserted where the index is, exactly
as in <code class="docutils literal notranslate"><span class="pre">oindex</span></code> given how specific they are to the axes they operate on:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create boolean index with one True value for the last two dimensions:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bindx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bindx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 1)</span>
</pre></div>
</div>
<p>But other advanced indices are again transposed to the front:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 6, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bindx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 5, 1)</span>
</pre></div>
</div>
<div class="section" id="motivational-example">
<h3>Motivational Example<a class="headerlink" href="#motivational-example" title="Permalink to this headline">¶</a></h3>
<p>Imagine having a data acquisition software storing <code class="docutils literal notranslate"><span class="pre">D</span></code> channels and
<code class="docutils literal notranslate"><span class="pre">N</span></code> datapoints along the time. She stores this into an <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">D)</span></code> shaped
array. During data analysis, we needs to fetch a pool of channels, for example
to calculate a mean over them.</p>
<p>This data can be faked using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>Now one may remember indexing with an integer array and find the correct code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">group</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_value</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</pre></div>
</div>
<p>However, assume that there were some specific time points (first dimension
of the data) that need to be specially considered. These time points are
already known and given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">interesting_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
</pre></div>
</div>
<p>Now to fetch them, we may try to modify the previous code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">group_at_it</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">interesting_times</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
<span class="go">IndexError: Ambiguous index, use `.oindex` or `.vindex`</span>
</pre></div>
</div>
<p>An error such as this will point to read up the indexing documentation.
This should make it clear, that <code class="docutils literal notranslate"><span class="pre">oindex</span></code> behaves more like slicing.
So, out of the different methods it is the obvious choice
(for now, this is a shape mismatch, but that could possibly also mention
<code class="docutils literal notranslate"><span class="pre">oindex</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">group_at_it</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[</span><span class="n">interesting_times</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
</pre></div>
</div>
<p>Now of course one could also have used <code class="docutils literal notranslate"><span class="pre">vindex</span></code>, but it is much less
obvious how to achieve the right thing!:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshaped_times</span> <span class="o">=</span> <span class="n">interesting_times</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group_at_it</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[</span><span class="n">reshaped_times</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
</pre></div>
</div>
<p>One may find, that for example our data is corrupt in some places.
So, we need to replace these values by zero (or anything else) for these
times. The first column may for example give the necessary information,
so that changing the values becomes easy remembering boolean indexing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bad_data</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="n">bad_data</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># (corrupts further examples)</span>
</pre></div>
</div>
<p>Again, however, the columns may need to be handled more individually (but in
groups), and the <code class="docutils literal notranslate"><span class="pre">oindex</span></code> attribute works well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">oindex</span><span class="p">[</span><span class="n">bad_data</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Note that it would be very hard to do this using legacy fancy indexing.
The only way would be to create an integer array first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bad_data_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">bad_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bad_data_indx_reshaped</span> <span class="o">=</span> <span class="n">bad_data_indx</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="n">bad_data_indx_reshaped</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
</pre></div>
</div>
<p>In any case we can use only <code class="docutils literal notranslate"><span class="pre">oindex</span></code> to do all of this without getting
into any trouble or confused by the whole complexity of advanced indexing.</p>
<p>But, some new features are added to the data acquisition. Different sensors
have to be used depending on the times. Let us assume we already have
created an array of indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">correct_sensors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Which lists for each time the two correct sensors in an <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">2)</span></code> array.</p>
<p>A first try to achieve this may be <code class="docutils literal notranslate"><span class="pre">arr[:,</span> <span class="pre">correct_sensors]</span></code> and this does
not work. It should be clear quickly that slicing cannot achieve the desired
thing. But hopefully users will remember that there is <code class="docutils literal notranslate"><span class="pre">vindex</span></code> as a more
powerful and flexible approach to advanced indexing.
One may, if trying <code class="docutils literal notranslate"><span class="pre">vindex</span></code> randomly, be confused about:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[:,</span> <span class="n">correct_sensors</span><span class="p">]</span>
</pre></div>
</div>
<p>which is neither the same, nor the correct result (see transposing rules)!
This is because slicing works still the same in <code class="docutils literal notranslate"><span class="pre">vindex</span></code>. However, reading
the documentation and examples, one can hopefully quickly find the desired
solution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># make shape fit with correct_sensors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">vindex</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">correct_sensors</span><span class="p">]</span>
</pre></div>
</div>
<p>At this point we have left the straight forward world of <code class="docutils literal notranslate"><span class="pre">oindex</span></code> but can
do random picking of any element from the array. Note that in the last example
a method such as mentioned in the <code class="docutils literal notranslate"><span class="pre">Related</span> <span class="pre">Questions</span></code> section could be more
straight forward. But this approach is even more flexible, since <code class="docutils literal notranslate"><span class="pre">rows</span></code>
does not have to be a simple <code class="docutils literal notranslate"><span class="pre">arange</span></code>, but could be <code class="docutils literal notranslate"><span class="pre">intersting_times</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">interesting_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">correct_sensors_at_it</span> <span class="o">=</span> <span class="n">correct_sensors</span><span class="p">[</span><span class="n">interesting_times</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interesting_times_reshaped</span> <span class="o">=</span> <span class="n">interesting_times</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_arr_it</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">interesting_times_reshaped</span><span class="p">,</span> <span class="n">correct_sensors_at_it</span><span class="p">]</span>
</pre></div>
</div>
<p>Truly complex situation would arise now if you would for example pool <code class="docutils literal notranslate"><span class="pre">L</span></code>
experiments into an array shaped <code class="docutils literal notranslate"><span class="pre">(L,</span> <span class="pre">N,</span> <span class="pre">D)</span></code>. But for <code class="docutils literal notranslate"><span class="pre">oindex</span></code> this should
not result into surprises. <code class="docutils literal notranslate"><span class="pre">vindex</span></code>, being more powerful, will quite
certainly create some confusion in this case but also cover pretty much all
eventualities.</p>
</div>
</div>
<div class="section" id="copyright">
<h2>Copyright<a class="headerlink" href="#copyright" title="Permalink to this headline">¶</a></h2>
<p>This document is placed under the CC0 1.0 Universell (CC0 1.0) Public Domain Dedication <a class="footnote-reference" href="#id4" id="id3">[1]</a>.</p>
</div>
<div class="section" id="references-and-footnotes">
<h2>References and Footnotes<a class="headerlink" href="#references-and-footnotes" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>To the extent possible under law, the person who associated CC0
with this work has waived all copyright and related or neighboring
rights to this work. The CC0 license may be found at
<a class="reference external" href="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[2]</a></td><td>e.g., see NEP 18,
<a class="reference external" href="http://www.numpy.org/neps/nep-0018-array-function-protocol.html">http://www.numpy.org/neps/nep-0018-array-function-protocol.html</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">NEP 21 — Simplified and explicit advanced indexing</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#background">Background</a><ul>
<li><a class="reference internal" href="#existing-indexing-operations">Existing indexing operations</a></li>
<li><a class="reference internal" href="#outer-indexing">Outer indexing</a></li>
<li><a class="reference internal" href="#mixed-indexing">Mixed indexing</a></li>
<li><a class="reference internal" href="#indexing-in-other-python-array-libraries">Indexing in other Python array libraries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#high-level-changes">High level changes</a></li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a><ul>
<li><a class="reference internal" href="#proposed-rules">Proposed rules</a></li>
<li><a class="reference internal" href="#open-questions">Open Questions</a></li>
<li><a class="reference internal" href="#alternative-names">Alternative Names</a></li>
<li><a class="reference internal" href="#subclasses">Subclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#backward-compatibility">Backward compatibility</a></li>
<li><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a><ul>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#legacy-fancy-indexing">Legacy fancy indexing</a></li>
<li><a class="reference internal" href="#id2">Outer indexing</a></li>
<li><a class="reference internal" href="#vectorized-inner-indexing">Vectorized/inner indexing</a><ul>
<li><a class="reference internal" href="#motivational-example">Motivational Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
<li><a class="reference internal" href="#references-and-footnotes">References and Footnotes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nep-0019-rng-policy.html"
                        title="previous chapter">NEP 19 — Random Number Generator Policy</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nep-0001-npy-format.html"
                        title="next chapter">NEP 1 — A Simple File Format for NumPy Arrays</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2017-2018, NumPy Developers.
      </li>
      <li>
      Last updated on Jan 13, 2019.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.9.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>